/*
import * as path from "path";
import * as fs from "fs";
import {getInfoFromFiles, createFile, createFunction, FunctionDefinition, ClassDefinition} from "./../main";

export function generateRenameFunctions() {
    const writeFileName = path.join(__dirname, "../../src/renameFunctions.ts");
    const result = getInfoFromFiles([path.join(__dirname, "../../src/definitions.ts")]);
    const definitionFiles = result.files.filter(f => f.fileName.indexOf("/definitions/") >= 0);
    const definitionClasses = definitionFiles.map(f => f.classes).reduce((a, b) => a.concat(...b), []);
    const fileForCreate = createFile({
        onBeforeWrite: (writer) => {
            writer.writeLine("// autogenerated file by gulp generate-rename-functions - DO NOT EDIT!!!").newLine();
        },
        fileName: writeFileName
    });
    const funcForCreate = createFunction({
        name: "renameDefinitionInFiles",
        isExported: true,
        parameters: [
            { name: "def", type: "NamedDefinition" },
            { name: "newName", type: "string" },
            { name: "files", type: "FileDefinition[]" }
        ]
    });
    const handleFunctions: { [name: string]: FunctionDefinition; } = {};

    definitionClasses.forEach(c => {
        const handleFunction = createFunction({
            name: "handle" + c.name,
            parameters: [{ name: "def", type: getTypeTextFromClass(c) }]
        });
        const extendedNames = getExtendedDefinitionNamesOfClass(c);

        handleFunction.onWriteFunctionBody = writer => {
            extendedNames.forEach(name => {
                writer.writeLine(`handle${name}(def)`);
            });

            c.properties.forEach(p => {
                p.type.getDefinitions().forEach(d => {
                    if (p.type.isArray()) {
                        console.log(p.type.types[0].definitions);
                        writer.writeLine(`(def.${p.name} || []).forEach(handle${d.name})`);
                    }
                    else {
                        writer.writeLine(`handle${d.name}(def.${p.name});`);
                    }
                });
            });
        };

        handleFunctions[c.name] = handleFunction;
        result.addDefinitionAsImportToFile({
            definition: c,
            file: fileForCreate
        });
    });

    fileForCreate.functions.push(funcForCreate);
    fileForCreate.functions.push(...Object.keys(handleFunctions).map(k => handleFunctions[k]));

    fs.writeFile(writeFileName, fileForCreate.write());
}

function getExtendedDefinitionNamesOfClass(classDef: ClassDefinition) {
    let definitionNames: { [name: string]: string } = {};

    classDef.extendsTypes.forEach(e => {
        e.getDefinitions().forEach(d => {
            definitionNames[d.name] = d.name;
        });
    });

    return Object.keys(definitionNames);
}

function getTypeTextFromClass(classDef: ClassDefinition) {
    let typeName = classDef.name;

    if (classDef.typeParameters.length > 0) {
        typeName += `<${classDef.typeParameters.map(p => "any").join(", ")}>`;
    }

    return typeName;
}
*/
